#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"


//------------------------------------------------------------------------------------------------//
//------------------------------------- INITIALIZATION---------------------------------------------//
//------------------------------------------------------------------------------------------------//

template<class T> class SparseVector{
private:
	//Add your data members here!
	std::vector<unsigned int> indices;
	std::vector<T> values;
	unsigned int dims;
public:
	//creates an empty vector of dimensionality 0.
	SparseVector();
	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim);

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added
	void setValue(unsigned int index, T value);

	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index) const;

	//returns the dimensionality of the vector
	unsigned int size() const;

	// returns the number stored elements
	unsigned int nonZeroes() const;
	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const;
	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const;

	//adds x to the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x);
	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x);
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y);

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y);


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x);

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A);

//------------------------------------------------------------------------------------------------//
//------------------------------------- IMPLEMENATION---------------------------------------------//
//------------------------------------------------------------------------------------------------//

//Default constructor
template<class T> SparseVector<T>::SparseVector()
{
    indices.resize(0);
	dims=0;
    values.resize(0);
}

//Constructor all-zeroes
template<class T> SparseVector<T>::SparseVector(unsigned int dim)
{
	indices.resize(0);
	dims = dim;
	values.resize(0);
}

//------------------------------------------------------------------------------------------------//

//Define value at a given index
template<class T> void SparseVector<T>::setValue(unsigned int index, T value){
    typename std::vector<T>::iterator V=values.begin();

    int n=std::distance(indices.begin(),std::lower_bound(indices.begin(),indices.end(),index));
	//Increments iterator by n elements, but only if the index is actually in the interval.
    std::advance(V, n);
    
    if(std::find(indices.begin(),indices.end(),index)==indices.end())
    {
        indices.insert(std::lower_bound(indices.begin(),indices.end(),index),index);
        values.insert(V,value);
    }
    else
    {
        *V = value;
    }

}

//Extract value a given index
template<class T> 
T SparseVector<T>::getValue(unsigned int index) const{
    if(std::find(indices.begin(),indices.end(),index)!=indices.end())
    {
        return values[std::distance(indices.begin(),std::lower_bound(indices.begin(),indices.end(),index))];
    }
    else{
        return 0;
    }
}

//Access private value dims 
template <class T> 
unsigned int SparseVector<T>::size() const{
return dims;
}

//------------------------------------------------------------------------------------------------//

//Number of zeroes
template<class T> 
unsigned int SparseVector<T>::nonZeroes()const
{
return indices.size();
}

//Indicies at the location of non-zero entries.
template<class T>
unsigned int SparseVector<T>::indexNonZero(unsigned int i)const
{
return indices[i];
}

//and the corresponding values at these locations
template<class T>
T SparseVector<T>::valueNonZero(unsigned int i)const
{
return values[i];
}

//------------------------------------------------------------------------------------------------//

//Addition with sparsevector x
template <class T>
SparseVector<T>& SparseVector<T>::operator+=(SparseVector<T> const& x){
	for (int j = 0; j < x.nonZeroes(); j++) {
		setValue(x.indexNonZero(j),x.valueNonZero(j) + getValue(x.indexNonZero(j)));
	}
return *this;
}

//Subtraction with sparsevector x
template <class T>
SparseVector<T>& SparseVector<T>::operator-=(SparseVector<T> const& x){
	for (int j = 0; j < x.nonZeroes(); j++){
		setValue(x.indexNonZero(j), -x.valueNonZero(j) + getValue(x.indexNonZero(j)));
	}
return *this;
}

//Add two sparsevectors
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){
	SparseVector<T> z = x;
	z+=y;
return z;
}

//Subtract two sparsevectors
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y){
	SparseVector<T> z = x;
	z-=y;
return z;
}


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
//Output is a dense vector
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x){
	int primo_size = x.size();
	int ultimo_size = A.GetNumberOfRows();

	//result vector
	Vector<T> res(ultimo_size);

	for (int l = 0 ;l < ultimo_size; l++){
		for (int k = 0; k<primo_size; k++){
			res[l] += A(l,k)*x.getValue(k);
		}
	}
return res;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// Output is a dense vector
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A){
	int primo_size = x.size();
	int ultimo_size = A.GetNumberOfRows();

	//result vector
	Vector<T> res(ultimo_size);
	
	for (int l = 0 ; l < ultimo_size; l++){
		for (int k = 0; k<primo_size; k++){
			res[l] += A(k,l)*x.getValue(k);
		}
	}
return res;
}


#endif
